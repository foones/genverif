
\subsection{Simply typed $\lambda$-calculus}

We assume given a denumerable set of \defn{atomic types} $\btyp,\btyptwo,\hdots$,
The set of \defn{types} is given by the grammar:
\[
  \typ,\typtwo,\hdots ::= \btyp \mid \typ\to\typtwo
\]
A \defn{type environment}, ranged over by $\tenv,\tenvtwo,\hdots$,
is a finite set of type assignments $\var_1:\typ_1,\hdots,\var_n:\typ_n$,
where $\var_1,\hdots,\var_n$ are distinct variables
and $\typ_1,\hdots,\typ_n$ are types.
We write $\dom{\tenv}$ for the set $\set{\var_1,\hdots,\var_n}$.
The set of \defn{terms} of the simply typed $\lambda$-calculus is
given by the grammar:
\[
  \tm, \tmtwo, \hdots ::= \var \mid \lam{\var}{\tm} \mid \tm\,\tmtwo
\]
A \defn{typing judgement} is an expression of the form $\judg{\tenv}{\tm}{\typ}$.
Valid judgements are defined inductively by the following rules:
\[
  \indrule{}{
  }{
    \judg{\tenv,\var:\typ}{\var}{\typ}
  }
  \HS
  \indrule{}{
    \judg{\tenv,\var:\typ}{\tm}{\typtwo}
  }{
    \judg{\tenv}{\lam{\var}{\tm}}{\typ\to\typtwo}
  }
  \HS
  \indrule{}{
    \judg{\tenv}{\tm}{\typ\to\typtwo}
    \HS
    \judg{\tenv}{\tmtwo}{\typ}
  }{
    \judg{\tenv}{\tm\,\tmtwo}{\typtwo}
  }
\]

\subsection{The $\lambdaCheck$-calculus}

We assume given a denumerable set of \defn{variables} $\var,\vartwo,\hdots$.
Our model relies on a variant of the (untyped) $\lambda$-calculus
that we dub the $\lambdaCheck$-calculus.
The set of terms is given by the grammar:
\[
  \begin{array}{lrll}
    \utm,\utmtwo,\hdots
  & ::=  & \var
         & \text{variable}
  \\
  & \mid & \lam{\var}{\utm}
         & \text{abstraction}
  \\
  & \mid & \utm\,\utmtwo
         & \text{application}
  \\
  & \mid & \iunit
         & \text{unit constructor}
  \\
  & \mid & \eunit{\utm}{\utmtwo}
         & \text{unit eliminator}
  \\
  & \mid & \genbtyp
         & \text{$\btyp$-generator}
  \\
  & \mid & \verifbtyp{\utm}
         & \text{$\btyp$-verifier}
  \end{array}
\]
Note that there are terms $\genbtyp$ and $\verifbtyp{\utm}$ for every
atomic type $\btyp$.
Terms are regarded up to $\alpha$-renaming of its bound variables.
We write $\utm\sub{\var}{\utmtwo}$ for the capture-avoiding substitution of
the free occurrences of $\var$ in $\utm$ by $\utmtwo$. 

A term is \defn{pure} if it only involves variables, abstractions, and applications.

A \defn{context} is a term with a single occurrence of a distinguished free
variable $\ctxhole$, called the hole.
If $\gctx$ is a context and $\utm$ is a term, we write $\ctxof{\gctx}{\utm}$
for the capturing substitution of the hole in $\gctx$ by $\utm$.
We write $\wctx,\wctx',\hdots$ to stand for \defn{weak head contexts}, which are
a subset of contexts generated by the following grammar:
\[
  \wctx ::= \ctxhole
       \mid \wctx\,\utm
       \mid \eunit{\wctx}{\utm}
       \mid \verifbtyp{\wctx}
\]

The binary relation of \defn{reduction}, written $\to$, is defined as the union
$\ctxof{\gctx}{\axBeta} \cup \ctxof{\gctx}{\axEIUnit} \cup \ctxof{\gctx}{\toVerifGen}$,
where $\ctxof{\gctx}{\mapsto_x}$ denotes the closure by arbitary contexts of
the rewriting rule $\mapsto_x$.
The three rewriting rules are:
\[
  \begin{array}{rll}
    (\lam{\var}{\utm})\,\utmtwo
    & \axBeta &
    \utm\sub{\var}{\utmtwo}
  \\
    \eunit{\iunit}{\utm}
    & \axEIUnit &
    \utm
  \\
    \verifbtyp{\genbtyp}
    & \axVerifGen &
    \iunit
  \end{array}
\]
Moreover, we write $\tow$ for \defn{weak head reduction}, defined as the union
$\ctxof{\wctx}{\axBeta} \cup \ctxof{\wctx}{\axEIUnit} \cup \ctxof{\wctx}{\axVerifGen}$,
where $\ctxof{\wctx}{\mapsto_x}$ denotes the closure by weak head contexts of
the rewriting rule $\mapsto_x$.
If ${\to_x} \subseteq X \times X$ is a binary relation,
we write $\to^0_x$ for the diagonal binary relation,
$\to^{n+1}_x \eqdef (\to_x \circ \to^n_x)$,
and $\tos_x$ for the reflexive--transitive closure of $\to_x$.

Intuitively, we use the constant $\iunit$ to represent that a computation ``succeeds''.
The eliminator $\eunit{\utm}{\utmtwo}$ can be used to check whether $\utm$
succeeds and return $\utmtwo$ if this is the case.
A term of the form $\genbtyp$
represents evidence for the atomic type $\btyp$,
while a term of the form $\verifbtyp{\utm}$ intuitively ``checks''
whether $\utm$ is evidence for the atomic type $\btyp$.

We adopt the convention that the unit eliminator has higher precedence than
the abstraction, but lower precedence than the application and
the $\btyp$-verifier, so for example
$\lam{\var}{\eunit{\verifbtyp{\utm}}{\utmtwo\,\utmthree}}$
is equivalent to
$\lam{\var}{(\eunit{(\verifbtyp{\utm})}{(\utmtwo\,\utmthree)})}$

\subsection{Generators and verifiers}

The $\lambdaCheck$-calculus includes generators and verifiers for atomic types.
We extend this to an arbitrary type $\typ$
by giving mutually recursive definitions of a term that
generates evidence of $\typ$ (written $\gen{\typ}$)
and a term that verifies whether its argument is evidence of $\typ$
(written $\verif{\typ}{\utm}$).

\begin{definition}[Generators and verifiers]
\label{def:generators_and_verifiers}
Let $\typ$ be a type.
The $\typ$-generator, written $\gen{\typ}$,
and the $\typ$-verifier, written $\verif{\typ}{\utm}$,
are terms of the untyped $\lambda$-calculus
defined as follows by induction on $\typ$.
In the base case, when $\typ = \btyp$ is an atomic type,
the definition coincides with the term constructors in the grammar
($\genbtyp$ and $\verifbtyp{\utm}$).
In the recursive case:
\[
  \begin{array}{rcl}
    \gen{\typ\to\typtwo}
  & \eqdef &
    \lam{\var}{(\eunit{\verif{\typ}{\var}}{\gen{\typtwo}})}
  \\
    \verif{\typ\to\typtwo}{\utm}
  & \eqdef &
    \verif{\typtwo}{(\utm\,\gen{\typ})}
  \end{array}
\]
\end{definition}

The definition of $\gen{\typ\to\typtwo}$ intuitively means that,
to generate evidence of $\typ\to\typtwo$,
we may construct an
abstraction $\lam{\var}{(\eunit{\verif{\typ}{\var}}{\gen{\typtwo}})}$
that checks whether its argument is evidence of $\typ$,
and then generates evidence of $\typtwo$.
The definition of $\verif{\typ\to\typtwo}{\utm}$ intuitively means that,
to verify whether $\utm$ is evidence of $\typ\to\typtwo$,
we provide $\utm$ with evidence of $\typ$, and check whether the
result is evidence of $\typtwo$.

